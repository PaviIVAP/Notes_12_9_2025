Encapsulation in Automation
=====================================================================================================
Use case: Wrapping request setup, headers, and payloads inside reusable methods or classes.

✅ REST Assured Example:
java
public class ApiClient {
    private RequestSpecification spec;

    public ApiClient() {
        spec = new RequestSpecBuilder()
                .setBaseUri("https://api.example.com")
                .addHeader("Authorization", "Bearer token")
                .build();
    }

    public Response getUser(String userId) {
        return given().spec(spec).get("/users/" + userId);
    }
}
🔸 Why it helps: You hide the setup logic and expose only what’s needed—like getUser()—making your tests cleaner and safer.
==============================================================================================================
🧬 Inheritance in Automation
Use case: Sharing common setup or teardown logic across test classes.

✅ TestNG + Selenium Example:
java
public class BaseTest {
    WebDriver driver;

    @BeforeMethod
    public void setup() {
        driver = new ChromeDriver();
    }

    @AfterMethod
    public void teardown() {
        driver.quit();
    }
}

public class LoginTest extends BaseTest {
    @Test
    public void testLogin() {
        driver.get("https://example.com/login");
        // test steps...
    }
}
🔸 Why it helps: You avoid repeating setup/teardown logic in every test class.

==============================================================================================================
🔁 Polymorphism in Automation
Use case: Defining a common interface for actions, then customizing behavior per page or API.

✅ Page Object Model Example:
java
interface Clickable {
    void click();
}

class Button implements Clickable {
    public void click() {
        System.out.println("Button clicked");
    }
}

class Link implements Clickable {
    public void click() {
        System.out.println("Link clicked");
    }
}
🔸 Why it helps: You can write generic test flows that work with any Clickable element, improving flexibility.

🧩 Abstraction in Automation
Use case: Defining high-level test actions without exposing internal steps.


==============================================================================================================
✅ REST Assured Example:
java
interface UserService {
    Response getUser(String userId);
    Response createUser(User user);
}

class UserServiceImpl implements UserService {
    public Response getUser(String userId) {
        return given().get("/users/" + userId);
    }

    public Response createUser(User user) {
        return given().body(user).post("/users");
    }
}
🔸 Why it helps: Your test class doesn’t care how the request is built—it just calls createUser() and gets results.

Would you like to go deeper into designing a reusable API test framework using these principles? Or maybe explore how to apply them in Dockerized CI/CD pipelines or Kubernetes test orchestration? I can tailor the next step to your current goal.

========================================================================================================================================


Compile-Time Polymorphism (Method Overloading)
🔍 What it is:
Achieved via method overloading—same method name, different parameter types or counts.

Resolved by the compiler before execution.

🧪 Example:
java
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}
💬 Interview Insight:
“Why is this compile-time?” Because the compiler knows exactly which method to call based on the method signature.

🚀 Runtime Polymorphism (Method Overriding)
🔍 What it is:
Achieved via method overriding—subclass provides its own version of a method defined in the superclass.

Resolved at runtime using dynamic method dispatch.

🧪 Example:
java
class Animal {
    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();  // Reference is Animal, object is Dog
        a.speak();             // Output: Dog barks
    }
}
💬 Interview Insight:
“Why is this runtime?” Because the actual method to execute (Dog.speak()) is determined while the program is running, based on the object type.

🧠 Real-World Automation Use
Compile-time polymorphism helps in utility classes (e.g., overloaded validate() methods for different data types).

Runtime polymorphism powers your Page Object Model—where BasePage.click() might behave differently in LoginPage vs DashboardPage.




EXAMPLE


1. Abstraction – Define a base class
java
abstract class Employee {
    String name;
    int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    abstract void calculateSalary();  // Abstract method
}
2. Inheritance – Extend base class
java
class FullTimeEmployee extends Employee {
    int monthlySalary;

    public FullTimeEmployee(String name, int id, int monthlySalary) {
        super(name, id);
        this.monthlySalary = monthlySalary;
    }

    @Override
    void calculateSalary() {
        System.out.println("Monthly Salary: " + monthlySalary);
    }
}

class PartTimeEmployee extends Employee {
    int hourlyRate;
    int hoursWorked;

    public PartTimeEmployee(String name, int id, int hourlyRate, int hoursWorked) {
        super(name, id);
        this.hourlyRate = hourlyRate;
        this.hoursWorked = hoursWorked;
    }

    @Override
    void calculateSalary() {
        System.out.println("Part-Time Salary: " + (hourlyRate * hoursWorked));
    }
}
3. Polymorphism – Use base class reference
java
public class Payroll {
    public static void main(String[] args) {
        Employee e1 = new FullTimeEmployee("Pavitha", 101, 50000);
        Employee e2 = new PartTimeEmployee("Ravi", 102, 500, 40);

        e1.calculateSalary();  // Calls FullTimeEmployee version
        e2.calculateSalary();  // Calls PartTimeEmployee version
    }
}
4. Encapsulation – Use private fields and getters/setters (optional)
java
class Department {
    private String deptName;

    public void setDeptName(String name) {
        this.deptName = name;
    }

    public String getDeptName() {
        return deptName;
    }
}

===========================================================================
INTERVIEW QUESTION


When you write:
java
Animal a = new Dog();
You get:
Method Type	Can You Call It?	Which Version Runs?
Method defined in Animal	✅ Yes	✅ Dog version if overridden, else Animal version
Method only in Dog	❌ No (unless cast)	✅ Only after casting: ((Dog)a).method()
🔍 Example
java
class Animal {
    void speak() { System.out.println("Animal speaks"); }
    void eat()   { System.out.println("Animal eats"); }
}

class Dog extends Animal {
    @Override
    void speak() { System.out.println("Dog barks"); }
    void wagTail() { System.out.println("Dog wags tail"); }
}
java
Animal a = new Dog();
a.speak();     // ✅ Dog barks (overridden)
a.eat();       // ✅ Animal eats (not overridden)
a.wagTail();   // ❌ Compile-time error
((Dog)a).wagTail(); // ✅ Dog wags tail
